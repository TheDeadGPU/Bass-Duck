<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rubber Ducky Bass Pulse</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #startAudio {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <button id="startAudio">Start Audio</button>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(-5, 10, 5);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    // Materials
    const yellow = new THREE.MeshStandardMaterial({ color: 0xffff00 });
    const orange = new THREE.MeshStandardMaterial({ color: 0xffa500 });
    const black = new THREE.MeshStandardMaterial({ color: 0x000000 });

    // Ducky group
    const ducky = new THREE.Group();
    scene.add(ducky);

    const body = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32), yellow);
    body.castShadow = true;
    ducky.add(body);

    const head = new THREE.Mesh(new THREE.SphereGeometry(0.6, 32, 32), yellow);
    head.position.set(0, 1, 0.5);
    head.castShadow = true;
    ducky.add(head);

    const beak = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.4, 32), orange);
    beak.rotation.x = Math.PI / 2;
    beak.position.set(0, 1, 1.1);
    beak.castShadow = true;
    ducky.add(beak);

    const eyeGeo = new THREE.SphereGeometry(0.05, 16, 16);
    const leftEye = new THREE.Mesh(eyeGeo, black);
    const rightEye = new THREE.Mesh(eyeGeo, black);
    leftEye.position.set(-0.5, 1.2, 0.7);
    rightEye.position.set(0.5, 1.2, 0.7);
    ducky.add(leftEye, rightEye);

    camera.position.z = 5;

    // Audio setup
    let analyser, dataArray;
    let currentScale = 1;

    function setupAudio() {
      const audio = new Audio('Inova - The Vibe (Original Mix).mp3');
      audio.crossOrigin = "anonymous";
      audio.loop = true;

      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const source = audioCtx.createMediaElementSource(audio);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 512;
      dataArray = new Uint8Array(analyser.frequencyBinCount);

      source.connect(analyser);
      analyser.connect(audioCtx.destination);

      audioCtx.resume().then(() => {
        audio.play();
      });
    }

    document.getElementById('startAudio').addEventListener('click', () => {
      setupAudio();
      document.getElementById('startAudio').style.display = 'none';
    });

    function getBassLevel(dataArray) {
      const bassBins = dataArray.slice(0, 10); // low frequencies
      return bassBins.reduce((a, b) => a + b, 0) / bassBins.length;
    }

    function animate() {
      requestAnimationFrame(animate);

      if (analyser && dataArray) {
        analyser.getByteFrequencyData(dataArray);
        const bass = getBassLevel(dataArray);
        const targetScale = 1 + bass / 200;
        //If you want smoothing, uncomment the lerp line and comment the direct assignment line
        //currentScale = THREE.MathUtils.lerp(currentScale, targetScale, 0.1);
        currentScale = targetScale / 2;
        ducky.scale.set(currentScale, currentScale, currentScale);
      }

      ducky.rotation.y += 0.01;
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
